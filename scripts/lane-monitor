#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  scripts/lane-monitor init [--config <path>] [--force]
  scripts/lane-monitor once [--config <path>]
  scripts/lane-monitor watch [--config <path>] [--interval <seconds>]
  scripts/lane-monitor start [--config <path>] [--interval <seconds>]
  scripts/lane-monitor stop [--config <path>]
  scripts/lane-monitor status [--config <path>]

Config format (TSV):
  lane<TAB>issue<TAB>pr<TAB>owner<TAB>note
USAGE
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

repo_root() {
  local script_dir
  local common_git_dir
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

  if common_git_dir=$(git -C "$script_dir" rev-parse --path-format=absolute --git-common-dir 2>/dev/null); then
    (cd "$(dirname "$common_git_dir")" && pwd)
    return
  fi

  (cd "$script_dir/.." && pwd)
}

trim_text() {
  local text="$1"
  local max_len="$2"
  if [ "${#text}" -le "$max_len" ]; then
    printf '%s' "$text"
    return
  fi
  printf '%s...' "${text:0:max_len-3}"
}

file_mtime_epoch() {
  local file="$1"
  if stat --version >/dev/null 2>&1; then
    stat -c '%Y' "$file"
    return
  fi
  stat -f '%m' "$file"
}

format_age() {
  local total="$1"
  local days hours minutes seconds
  if [ "$total" -lt 60 ]; then
    printf '%ss' "$total"
    return
  fi
  if [ "$total" -lt 3600 ]; then
    minutes=$((total / 60))
    seconds=$((total % 60))
    printf '%sm%ss' "$minutes" "$seconds"
    return
  fi
  if [ "$total" -lt 86400 ]; then
    hours=$((total / 3600))
    minutes=$(((total % 3600) / 60))
    printf '%sh%sm' "$hours" "$minutes"
    return
  fi
  days=$((total / 86400))
  hours=$(((total % 86400) / 3600))
  printf '%sd%sh' "$days" "$hours"
}

config_default=".local/lanes.tsv"
interval_default="60"

mode="${1:-}"
if [ -z "$mode" ] || [ "$mode" = "-h" ] || [ "$mode" = "--help" ]; then
  usage
  exit 0
fi
shift || true

config_path="$config_default"
interval="$interval_default"
force="false"

while [ "$#" -gt 0 ]; do
  case "$1" in
    --config)
      config_path="${2:-}"
      shift 2
      ;;
    --interval)
      interval="${2:-}"
      shift 2
      ;;
    --force)
      force="true"
      shift
      ;;
    *)
      echo "unknown option: $1" >&2
      usage
      exit 2
      ;;
  esac
done

case "$interval" in
  ''|*[!0-9]*)
    echo "--interval must be a positive integer" >&2
    exit 2
    ;;
  0)
    echo "--interval must be at least 1 second" >&2
    exit 2
    ;;
esac

root="$(repo_root)"
cd "$root"

if [[ "$config_path" != /* ]]; then
  config_path="$root/$config_path"
fi

config_dir="$(dirname "$config_path")"
state_dir="$config_dir/.lane-monitor"
pid_file="$state_dir/pid"
latest_file="$state_dir/latest.txt"
history_file="$state_dir/history.log"

ensure_state_dir() {
  mkdir -p "$state_dir"
}

ensure_config_exists() {
  if [ ! -f "$config_path" ]; then
    echo "missing config: $config_path" >&2
    echo "run: scripts/lane-monitor init --config $config_path" >&2
    exit 1
  fi
}

is_running() {
  if [ ! -f "$pid_file" ]; then
    return 1
  fi
  local pid
  pid="$(cat "$pid_file" 2>/dev/null || true)"
  if [ -z "$pid" ]; then
    return 1
  fi
  kill -0 "$pid" >/dev/null 2>&1
}

gh_mode() {
  if ! command_exists gh; then
    printf 'missing'
    return
  fi

  local status_json
  status_json="$(gh auth status --hostname github.com --json hosts 2>&1 || true)"
  if printf '%s' "$status_json" | grep -q '"state":"success"'; then
    printf 'ok'
    return
  fi

  local detail_lc
  detail_lc="$(printf '%s' "$status_json" | tr '[:upper:]' '[:lower:]')"
  case "$detail_lc" in
    *token*invalid*|*token*expired*|*bad\ credentials*|*authentication\ failed*|*failed\ to\ log\ in*|*requires\ authentication*)
      printf 'auth_err'
      ;;
    *dial\ tcp*|*lookup*|*no\ such\ host*|*i/o\ timeout*|*timeout*|*timed\ out*|*could\ not\ resolve\ host*|*network\ is\ unreachable*|*connection\ refused*|*operation\ not\ permitted*|*tls\ handshake*|*temporary\ failure*)
      printf 'net_err'
      ;;
    *)
      printf 'gh_err'
      ;;
  esac
}

issue_status() {
  local issue="$1"
  local mode="$2"
  if [ "$mode" = "missing" ]; then
    printf 'NO_GH\t-\t-\t-'
    return
  fi
  if [ "$mode" = "auth_err" ]; then
    printf 'AUTH_ERR\t-\t-\t-'
    return
  fi
  if [ "$mode" = "net_err" ]; then
    printf 'NET_ERR\t-\t-\t-'
    return
  fi
  if [ "$mode" = "gh_err" ]; then
    printf 'GH_ERR\t-\t-\t-'
    return
  fi

  local out
  if ! out="$(gh issue view "$issue" --json state,title,url --jq '[.state,.title,.url] | @tsv' 2>/dev/null)"; then
    printf 'ERR\t-\t-\t-'
    return
  fi

  local state title url
  IFS=$'\t' read -r state title url <<< "$out"
  printf '%s\t%s\t%s\t-' "$state" "$title" "$url"
}

pr_status() {
  local pr="$1"
  local mode="$2"
  if [ -z "$pr" ] || [ "$pr" = "-" ]; then
    printf '%s\t%s\t%s' '-' '-' '-'
    return
  fi
  if [ "$mode" = "missing" ]; then
    printf 'NO_GH\t-\t-'
    return
  fi
  if [ "$mode" = "auth_err" ]; then
    printf 'AUTH_ERR\t-\t-'
    return
  fi
  if [ "$mode" = "net_err" ]; then
    printf 'NET_ERR\t-\t-'
    return
  fi
  if [ "$mode" = "gh_err" ]; then
    printf 'GH_ERR\t-\t-'
    return
  fi

  local out
  if ! out="$(gh pr view "$pr" --json state,isDraft,mergeStateStatus,url --jq '[.state, (if .isDraft then \"DRAFT\" else \"READY\" end), .mergeStateStatus, .url] | @tsv' 2>/dev/null)"; then
    printf 'ERR\t-\t-'
    return
  fi

  local state draft merge_status url
  IFS=$'\t' read -r state draft merge_status url <<< "$out"
  printf '%s/%s/%s\t%s\t-' "$state" "$draft" "$merge_status" "$url"
}

latest_report_info() {
  local lane="$1"
  local now best_epoch best_file
  local report_dir epoch candidate base
  now="$(date -u +%s)"
  best_epoch=0
  best_file=""

  for report_dir in "$root/.worktrees/$lane/.local/agent-reports" "$root/.local/agent-reports"; do
    [ -d "$report_dir" ] || continue
    while IFS= read -r -d '' candidate; do
      epoch="$(file_mtime_epoch "$candidate" 2>/dev/null || echo 0)"
      if [ "$epoch" -gt "$best_epoch" ]; then
        best_epoch="$epoch"
        best_file="$candidate"
      fi
    done < <(find "$report_dir" -maxdepth 1 -type f -name '*.md' -print0 2>/dev/null)
  done

  if [ -z "$best_file" ]; then
    printf '%s\t%s\t%s' '-' '-' '-'
    return
  fi

  base="$(basename "$best_file")"
  epoch=$((now - best_epoch))
  if [ "$epoch" -lt 0 ]; then
    epoch=0
  fi
  printf '%s\t%s\t%s' "$base" "$(format_age "$epoch")" "$best_file"
}

tmux_lane_state() {
  local lane="$1"
  local pane_out pane_dead pane_cmd
  if ! command_exists tmux; then
    printf 'NO_TMUX'
    return
  fi
  if ! tmux has-session -t codex-lanes 2>/dev/null; then
    printf 'NO_SESSION'
    return
  fi

  pane_out="$(tmux list-panes -t "codex-lanes:$lane" -F '#{pane_dead}\t#{pane_current_command}' 2>/dev/null | head -n 1 || true)"
  if [ -z "$pane_out" ]; then
    printf 'MISSING'
    return
  fi

  IFS=$'\t' read -r pane_dead pane_cmd <<< "$pane_out"
  if [ "${pane_dead:-1}" = "1" ]; then
    printf 'DEAD'
    return
  fi
  if [ "${pane_cmd:-}" = "codex" ]; then
    printf 'CODEX'
    return
  fi
  pane_cmd="$(trim_text "${pane_cmd:-?}" 7)"
  printf 'RUN:%s' "$pane_cmd"
}

snapshot() {
  ensure_config_exists

  local now gh_ready
  now="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
  gh_ready="$(gh_mode)"

  printf 'timestamp=%s\n' "$now"
  printf 'config=%s\n' "$config_path"
  printf 'gh_auth=%s\n' "$gh_ready"
  printf '%-8s %-7s %-6s %-12s %-23s %-12s %-14s %-20s %-16s %-8s %s\n' \
    "lane" "issue" "pr" "issue_state" "pr_state" "tmux" "owner" "issue_title" "last_report" "age" "note"

  while IFS=$'\t' read -r lane issue pr owner note || [ -n "${lane:-}" ]; do
    [ -z "${lane:-}" ] && continue
    [[ "$lane" = \#* ]] && continue
    if [ -z "${issue:-}" ]; then
      continue
    fi

    local issue_out pr_out issue_state issue_title issue_url pr_state pr_url
    local tmux_state report_out report_file report_age report_path
    issue_out="$(issue_status "$issue" "$gh_ready")"
    pr_out="$(pr_status "${pr:-}" "$gh_ready")"
    tmux_state="$(tmux_lane_state "$lane")"
    report_out="$(latest_report_info "$lane")"

    IFS=$'\t' read -r issue_state issue_title issue_url _ <<< "$issue_out"
    IFS=$'\t' read -r pr_state pr_url _ <<< "$pr_out"
    IFS=$'\t' read -r report_file report_age report_path <<< "$report_out"

    issue_title="$(trim_text "${issue_title:--}" 20)"
    note="$(trim_text "${note:--}" 50)"
    report_file="$(trim_text "${report_file:--}" 16)"

    printf '%-8s %-7s %-6s %-12s %-23s %-12s %-14s %-20s %-16s %-8s %s\n' \
      "$lane" "$issue" "${pr:--}" "${issue_state:--}" "${pr_state:--}" "${tmux_state:--}" "${owner:--}" "$issue_title" "${report_file:--}" "${report_age:--}" "$note"
    printf '  issue_url: %s\n' "${issue_url:--}"
    if [ "${pr:-}" != "-" ] && [ -n "${pr:-}" ]; then
      printf '  pr_url:    %s\n' "${pr_url:--}"
    fi
    if [ "${report_path:--}" != "-" ]; then
      printf '  report:    %s\n' "${report_path:--}"
    fi
  done < "$config_path"
}

write_snapshot_files() {
  ensure_state_dir
  local output
  output="$(snapshot)"
  printf '%s\n' "$output" > "$latest_file"
  {
    printf '==== %s ====\n' "$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
    printf '%s\n\n' "$output"
  } >> "$history_file"
  printf '%s\n' "$output"
}

run_daemon_loop() {
  trap 'exit 0' INT TERM
  while true; do
    write_snapshot_files
    sleep "$interval"
  done
}

case "$mode" in
  init)
    mkdir -p "$config_dir"
    if [ -f "$config_path" ] && [ "$force" != "true" ]; then
      echo "config already exists: $config_path" >&2
      echo "use --force to overwrite" >&2
      exit 1
    fi
    cat > "$config_path" <<'EOF'
# lane<TAB>issue<TAB>pr<TAB>owner<TAB>note
lane1	25	-	codex-a	mvp lane 1
lane2	26	-	codex-b	mvp lane 2
lane3	27	-	codex-c	mvp lane 3
EOF
    echo "wrote $config_path"
    ;;
  once)
    write_snapshot_files
    ;;
  watch)
    while true; do
      clear
      write_snapshot_files
      sleep "$interval"
    done
    ;;
  start)
    ensure_state_dir
    if is_running; then
      echo "lane monitor already running (pid $(cat "$pid_file"))"
      exit 0
    fi
    rm -f "$pid_file"
    nohup "$0" run-daemon --config "$config_path" --interval "$interval" > "$state_dir/live.log" 2>&1 &
    echo "$!" > "$pid_file"
    echo "lane monitor started (pid $(cat "$pid_file"))"
    echo "log: $state_dir/live.log"
    ;;
  stop)
    ensure_state_dir
    if ! is_running; then
      rm -f "$pid_file"
      echo "lane monitor is not running"
      exit 0
    fi
    pid="$(cat "$pid_file")"
    kill "$pid"
    rm -f "$pid_file"
    echo "lane monitor stopped (pid $pid)"
    ;;
  status)
    ensure_state_dir
    if is_running; then
      echo "lane monitor: running (pid $(cat "$pid_file"))"
    else
      echo "lane monitor: stopped"
    fi
    if [ -f "$latest_file" ]; then
      echo
      cat "$latest_file"
    else
      echo "no snapshot yet"
    fi
    ;;
  run-daemon)
    run_daemon_loop
    ;;
  *)
    echo "unknown mode: $mode" >&2
    usage
    exit 2
    ;;
esac
